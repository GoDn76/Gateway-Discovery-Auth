#server:
#  port: 9090
#
#spring:
#  cloud:
#    gateway:
#      server:
#        webflux:
#          routes:
#            # A. Public Auth Routes (Login/Register)
#                    - id: user-service-route
#                      uri: lb://user-service
#                      predicates:
#                        - Path=/auth/**
#                      filters:
#                        - StripPrefix=1
#
#                    # B. Protected User Routes (Profile/Update)
#                    - id: user-service-protected
#                      uri: lb://user-service
#                      predicates:
#                        - Path=/user/**
#                      filters:
#                        - StripPrefix=1
#                        - AuthenticationFilter # Custom Filter Bean
#
#                    # C. Protected Upload Routes (Deployments)
#                    - id: upload-service
#                      uri: lb://upload-service
#                      predicates:
#                        - Path=/jsd/** # Frontend calls /jsd/deployments
#                      filters:
#                        - StripPrefix=1      # Service receives /deployments
#                        - AuthenticationFilter
#          globalcors:
#            cors-configurations:
#              '[/**]':
#                          allowedOrigins: "*"   # Allow your frontend URL
#                          allowedMethods:
#                            - GET
#                            - POST
#                            - PUT
#                            - DELETE
#                            - OPTIONS
#                          allowedHeaders: "*"
#
#jwt:
#  secret: ${JWT_SECRET}
#  expiration-ms: 86400000
#
#eureka:
#  client:
#    service-url:
#      # Use localhost because Gateway & Eureka are on the same VM
#      defaultZone: ${EUREKA_SERVER_URL:http://localhost:8761/eureka/}
#


server:
  port: 9090

spring:
  application:
    name: api-gateway
  data:
    redis:
      host: localhost
      port: 6379
  cloud:
    gateway:
      # Global CORS (Applied to all routes)
      # --- ROUTES CONFIGURATION ---
      server:
        webflux:
          globalcors:
            cors-configurations:
              '[/**]':
                          allowedOrigins: "*"
                          allowedMethods: "*"
                          allowedHeaders: "*"
          routes:
            # A. Public Auth Routes (Login/Register)
                    # Needs high throughput, but protection against DDoS
                    - id: user-service-route
                      uri: lb://user-service
                      predicates:
                        - Path=/auth/**
                      filters:
                        - StripPrefix=1
                        - name: CircuitBreaker
                          args:
                            name: userServiceBreaker
                            fallbackUri: forward:/fallback/auth
                        - name: RequestRateLimiter
                          args:
                            redis-rate-limiter.replenishRate: 10  # 10 req/sec (steady)
                            redis-rate-limiter.burstCapacity: 20  # Allow burst of 20
                            key-resolver: "#{@userKeyResolver}"   # Bean we will define below

                    # B. Protected User Routes (Profile/Update)
                    - id: user-service-protected
                      uri: lb://user-service
                      predicates:
                        - Path=/user/**
                      filters:
                        - StripPrefix=1
                        - AuthenticationFilter
                        - name: CircuitBreaker
                          args:
                            name: userServiceBreaker
                            fallbackUri: forward:/fallback/user

                    # C. Protected Upload Routes (Deployments)
                    # CRITICAL: Needs stricter limits because cloning/uploading is heavy!
                    - id: upload-service
                      uri: lb://upload-service
                      predicates:
                        - Path=/jsd/**
                      filters:
                        - StripPrefix=1
                        - AuthenticationFilter
                        - name: CircuitBreaker
                          args:
                            name: uploadServiceBreaker
                            fallbackUri: forward:/fallback/deploy
                        - name: RequestRateLimiter
                          args:
                            redis-rate-limiter.replenishRate: 2   # Only 2 req/sec (prevent spamming deploy)
                            redis-rate-limiter.burstCapacity: 5
                            key-resolver: "#{@userKeyResolver}"

# --- RESILIENCE4J CONFIGURATION ---
resilience4j:
  circuitbreaker:
    instances:
      # Config for User Service (Fast, DB interactions)
      userServiceBreaker:
        registerHealthIndicator: true
        slidingWindowSize: 10
        failureRateThreshold: 50
        waitDurationInOpenState: 5s
        permittedNumberOfCallsInHalfOpenState: 3

      # Config for Upload Service (Slower, External API calls)
      uploadServiceBreaker:
        registerHealthIndicator: true
        slidingWindowSize: 10
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
        permittedNumberOfCallsInHalfOpenState: 2

  timelimiter:
    instances:
      userServiceBreaker:
        timeoutDuration: 3s  # Auth should never take > 3s
      uploadServiceBreaker:
        timeoutDuration: 10s # GitHub API might be slow, give it time

jwt:
  secret: ${JWT_SECRET}
  expiration-ms: 86400000

eureka:
  client:
    service-url:
      defaultZone: ${EUREKA_SERVER_URL:http://localhost:8761/eureka/}